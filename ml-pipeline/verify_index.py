"""
Verify integrity of Faiss index files generated by build_index.py.

Checks:
  1. All expected files exist and are loadable
  2. Consistency between index, labels, and class mapping

Usage:
    python verify_index.py --index_dir ./index
"""
import argparse
import sys
from pathlib import Path

import faiss
import numpy as np
import torch

from utils import load_json


def verify(index_dir: Path) -> list[str]:
    """
    Verify index files and return list of errors (empty = all passed).
    """
    errors = []

    index_path = index_dir / "gallery.index"
    labels_path = index_dir / "gallery_labels.npy"
    class_to_idx_path = index_dir / "class_to_idx.json"
    model_path = index_dir / "model.pt"

    # 1. File existence
    for path in [index_path, labels_path, class_to_idx_path, model_path]:
        if not path.exists():
            errors.append(f"Missing file: {path}")
    if errors:
        return errors

    # 2. Load files
    try:
        index = faiss.read_index(str(index_path))
    except Exception as e:
        errors.append(f"Failed to load Faiss index: {e}")
        return errors

    try:
        labels = np.load(str(labels_path))
    except Exception as e:
        errors.append(f"Failed to load labels: {e}")
        return errors

    try:
        class_to_idx = load_json(class_to_idx_path)
    except Exception as e:
        errors.append(f"Failed to load class_to_idx.json: {e}")
        return errors

    # 3. Index dimension
    if index.d != 512:
        errors.append(f"Index dimension mismatch: expected 512, got {index.d}")

    # 4. Non-empty
    if index.ntotal == 0:
        errors.append("Index is empty (0 vectors)")

    if len(labels) == 0:
        errors.append("Labels array is empty")

    if len(class_to_idx) == 0:
        errors.append("class_to_idx is empty")

    # 5. Count consistency: index vectors == label count
    if index.ntotal != len(labels):
        errors.append(
            f"Count mismatch: index has {index.ntotal} vectors"
            f" but labels has {len(labels)} entries"
        )

    # 6. Label range validity
    num_classes = len(class_to_idx)
    if len(labels) > 0:
        min_label, max_label = int(labels.min()), int(labels.max())
        if min_label < 0:
            errors.append(f"Negative label found: {min_label}")
        if max_label >= num_classes:
            errors.append(
                f"Label {max_label} out of range for {num_classes} classes"
            )

    # 7. class_to_idx index completeness (should be 0..N-1)
    expected_indices = set(range(num_classes))
    actual_indices = set(class_to_idx.values())
    if actual_indices != expected_indices:
        errors.append(
            f"class_to_idx indices are not contiguous 0..{num_classes - 1}:"
            f" got {sorted(actual_indices)}"
        )

    # 8. TorchScript model verification
    try:
        ts_model = torch.jit.load(str(model_path), map_location="cpu")
    except Exception as e:
        errors.append(f"Failed to load TorchScript model: {e}")
        return errors

    try:
        ts_model.eval()
        dummy = torch.randn(1, 3, 480, 480)
        with torch.no_grad():
            logits, embeddings = ts_model(dummy)
        if embeddings.shape[1] != index.d:
            errors.append(
                f"TorchScript embedding dim {embeddings.shape[1]}"
                f" != index dim {index.d}"
            )
        if logits.shape[1] != num_classes:
            errors.append(
                f"TorchScript logits dim {logits.shape[1]}"
                f" != num_classes {num_classes}"
            )
    except Exception as e:
        errors.append(f"TorchScript model inference failed: {e}")

    return errors


def main():
    parser = argparse.ArgumentParser(description="Verify Faiss index integrity")
    parser.add_argument(
        "--index_dir", type=str, default="./index", help="Index directory"
    )
    args = parser.parse_args()

    index_dir = Path(args.index_dir)
    print(f"Verifying index at: {index_dir}")

    errors = verify(index_dir)

    if errors:
        print(f"\nFAILED — {len(errors)} error(s):")
        for e in errors:
            print(f"  - {e}")
        sys.exit(1)
    else:
        # Print summary on success
        index = faiss.read_index(str(index_dir / "gallery.index"))
        labels = np.load(str(index_dir / "gallery_labels.npy"))
        class_to_idx = load_json(index_dir / "class_to_idx.json")

        print(f"\nPASSED — all checks OK")
        print(f"  Vectors:    {index.ntotal}")
        print(f"  Dimension:  {index.d}")
        print(f"  Classes:    {len(class_to_idx)}")
        print(f"  Labels:     {dict(zip(*np.unique(labels, return_counts=True)))}")


if __name__ == "__main__":
    main()
